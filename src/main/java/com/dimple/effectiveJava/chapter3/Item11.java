package com.dimple.effectiveJava.chapter3;

/**
 * @className: Item11
 * @description: 覆盖equals时总要覆盖hashCode
 * 在每个覆盖equals方法的类中，都需要覆盖hashCode方法，如果不这样做，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的几个一起正常运作，这其中就包括HashMap和HashSet。
 * Object规范：
 * 1. 在应用执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一对象的多次调用，hashCode方法的返回值必须始终返回同一个值。在不同应用程序中可以不同。
 * 2. 如果两个对象根据equals（Object）方法比较的结果是相等的，那么调用两个对象的HashCode方法必须返回同样的结果。
 * 3. 如果两个对象的equals（Object）方法比较是不相等的，那么调用这两个对象的hashCode方法返回值不要求相等，但是不同的对象产生截然不同的整数结果，可以提高散列表（HashTable）的效率。
 * 因没有覆盖hashCode方法违反的约定是第二条：相等的对象必须要具有相同的HashCode。
 * <p>
 * 理想情况下，散列函数应该将集合中不相等的实例均匀的分布到所有可能的int值上，以下是做到接近这个理想条件的解决办法：
 * 1. 声明一个int类型变量并命名为result，将它初始化为对象中第一个关键域的hashCode，如2.a中计算方法：
 * 2. 对象中的每一个域都完成以下步骤：
 * a. 为该域计算int类型的散列码：
 * I： 如果为基本类型，则计算Type.hashCode(f)，这里的Type是装箱基本类型的类，与f的类型对应。
 * II：如果该域为对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样为这个域递归调用hashCode。如果域的值为null，则返回0（或者其他常数，一般是0）
 * III：如果该域是一个数组，则需要将每一个元素当做一个单独的域进行处理。也就是说递归的应用上面的规则，对每个重要的元素计算一个散列码，如果域中没有重要的元素，可以使用一个常年，但最好不是0。如果数组域中的元素痘坑重要，可以使用Arrays.hashCode方法。
 * b. 按照以下公式，将步骤2.a中得到的散列码c合并到result中： 【result=31*result+c】
 * 3. 返回result。
 * <p>
 * 必须要排除在equals中没有用到的域，否则很可能违反第二条。
 * <p>
 * 之所以使用31，是因为它是一个奇素数。如果乘数是偶数，并且乘法移除，信息就会丢失，因为与2相乘等价于移位运算。31可以用移位和减法来代替乘法，以得到更好的性能：31*i==(i<<5)-i
 * @auther: Dimple
 * @date: 05/27/19
 * @version: 1.0
 */
public class Item11 {
}
